This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-11-28T16:35:35.299Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
app/
  api/
    cleanup/
      route.ts
    images/
      route.ts
    prompts/
      route.ts
    uploads/
      route.ts
    utils/
      multerConfig.ts
  components/
    CameraModal.tsx
    PromptGrid.tsx
  services/
    api.ts
    apiClient.ts
    db.ts
    pdfGenerator.ts
    zipImages.ts
  app.css
  globals.css
  layout.tsx
  page.module.css
  page.tsx
.gitignore
eslint.config.js
index.html
next-env.d.ts
next.config.ts
package.json
README.md
tsconfig.app.json
tsconfig.json
tsconfig.node.json
vite.config.ts

================================================================
Repository Files
================================================================

================
File: app/api/cleanup/route.ts
================
import { NextRequest, NextResponse } from "next/server";
import fs from "fs/promises";
import path from "path";

export async function GET(req: NextRequest) {
  try {
    // Adjust the directory path to your upload folder
    const directory = path.join(process.cwd(), "uploads");

    // Read the files in the directory
    const files = await fs.readdir(directory);

    // Delete each file in the directory
    await Promise.all(
      files.map(async (file) => {
        const filePath = path.join(directory, file);
        try {
          await fs.unlink(filePath);
          console.log(`Deleted file: ${file}`);
        } catch (err) {
          console.error(`Failed to delete file: ${file}`, err);
        }
      })
    );

    return NextResponse.json({ message: "Uploads directory cleaned up" });
  } catch (err) {
    console.error("Error cleaning uploads directory:", err);
    return NextResponse.json(
      { error: "Failed to clean uploads directory" },
      { status: 500 }
    );
  }
}

================
File: app/api/images/route.ts
================
import { NextRequest, NextResponse } from "next/server";
import { promises as fsPromises } from "fs";
import path from "path";
import { PDFDocument } from "pdf-lib";
import formidable from "formidable";

// Directory to temporarily store uploaded images
const uploadDir = path.join(process.cwd(), "uploads");

// Ensure the directory exists
const ensureUploadDir = async () => {
  try {
    await fsPromises.mkdir(uploadDir, { recursive: true });
  } catch (err) {
    console.error("Error ensuring upload directory exists:", err);
  }
};

// Temporary storage for uploaded file paths
let uploadedImages: string[] = [];

// Utility to clean up files
const cleanUp = async (files: string[]) => {
  for (const file of files) {
    try {
      await fsPromises.unlink(file);
    } catch (err) {
      console.error(`Error deleting file ${file}:`, err);
    }
  }
};

// POST endpoint: Handle file upload
export async function POST(req: NextRequest) {
  await ensureUploadDir();

  const form = formidable({
    multiples: true,
    uploadDir: uploadDir,
    keepExtensions: true,
  });

  try {
    const { files } = await new Promise<{ fields: formidable.Fields; files: formidable.Files }>(
      (resolve, reject) => {
        form.parse(req.body as any, (err, fields, files) => {
          if (err) reject(err);
          else resolve({ fields, files });
        });
      }
    );

    if (!files || Object.keys(files).length === 0) {
      return NextResponse.json({ error: "No images uploaded" }, { status: 400 });
    }

    // Safely map file paths
    const fileArray = Array.isArray(files.images) ? files.images : [files.images];
    uploadedImages = fileArray
      .filter((file): file is formidable.File => Boolean(file && "filepath" in file)) // Type guard to ensure `file` is `formidable.File`
      .map((file) => file.filepath);

    return NextResponse.json({ message: "Images uploaded successfully" });
  } catch (error) {
    console.error("Error handling file upload:", error);
    return NextResponse.json({ error: "File upload failed" }, { status: 500 });
  }
}

// GET endpoint: Generate PDF from uploaded images
export async function GET() {
  if (uploadedImages.length === 0) {
    return NextResponse.json({ error: "No images available for PDF" }, { status: 400 });
  }

  try {
    const pdfDoc = await PDFDocument.create();

    for (const imagePath of uploadedImages) {
      const imageBytes = await fsPromises.readFile(imagePath);
      const image = await pdfDoc.embedJpg(imageBytes); // Use embedPng for PNG images
      const page = pdfDoc.addPage([image.width, image.height]);
      page.drawImage(image, { x: 0, y: 0, width: image.width, height: image.height });
    }

    const pdfBytes = await pdfDoc.save();

    // Clean up uploaded images
    await cleanUp(uploadedImages);
    uploadedImages = [];

    return new NextResponse(Buffer.from(pdfBytes), {
      headers: {
        "Content-Type": "application/pdf",
        "Content-Disposition": `attachment; filename="images.pdf"`,
      },
    });
  } catch (error) {
    console.error("Error generating PDF:", error);
    return NextResponse.json({ error: "Failed to generate PDF" }, { status: 500 });
  }
}

================
File: app/api/prompts/route.ts
================
import { NextRequest, NextResponse } from "next/server";

interface Prompt {
	fullPrompt: string;
	shortPrompt: string;
}

let promptSets: { [key: string]: Prompt[] } = {
    books: [
        { "fullPrompt": "A book that reminds you of us", "shortPrompt": "Reminds you of us" },
        { "fullPrompt": "A book with the weirdest cover", "shortPrompt": "Weirdest cover" },
        { "fullPrompt": "A book with a blue spine", "shortPrompt": "Blue spine" },
        { "fullPrompt": "A book by an author you’ve never heard of", "shortPrompt": "Unknown author" },
        { "fullPrompt": "A book that feels like home", "shortPrompt": "Feels like home" },
        { "fullPrompt": "A book with a title that’s a question", "shortPrompt": "Title as question" },
        { "fullPrompt": "A book about something you love", "shortPrompt": "About something you love" },
        { "fullPrompt": "A book set in a place you’ve always wanted to visit", "shortPrompt": "Dream destination" },
        { "fullPrompt": "A book with an animal on the cover", "shortPrompt": "Animal on cover" },
        { "fullPrompt": "A book with a number in the title", "shortPrompt": "Number in title" },
        { "fullPrompt": "A book written in verse", "shortPrompt": "Written in verse" },
        { "fullPrompt": "A book that makes you laugh just from its title", "shortPrompt": "Funny title" },
        { "fullPrompt": "A book from the year you were born", "shortPrompt": "From your birth year" },
        { "fullPrompt": "A book with an epic first sentence", "shortPrompt": "Epic first sentence" },
        { "fullPrompt": "A book with illustrations inside", "shortPrompt": "Illustrations inside" },
        { "fullPrompt": "A book that feels mysterious", "shortPrompt": "Feels mysterious" },
        { "fullPrompt": "A book you think would make a great gift", "shortPrompt": "Great gift" },
        { "fullPrompt": "A book with a character who shares your name", "shortPrompt": "Your name in it" },
        { "fullPrompt": "A book that you think would be a bestseller in 100 years", "shortPrompt": "Future bestseller" },
        { "fullPrompt": "A book with a flower on the cover", "shortPrompt": "Flower on cover" },
        { "fullPrompt": "A book set during a holiday", "shortPrompt": "Set during a holiday" },
        { "fullPrompt": "A book by an author who has the same initials as you", "shortPrompt": "Author with your initials" },
        { "fullPrompt": "A book with more than 500 pages", "shortPrompt": "500+ pages" },
        { "fullPrompt": "A book from a genre you don’t usually read", "shortPrompt": "New genre for you" }
      ],
      art: [
        { "fullPrompt": "An artwork that feels like it could tell you a secret", "shortPrompt": "Secretive artwork" },
        { "fullPrompt": "A painting with the brightest colors you’ve ever seen", "shortPrompt": "Brightest colors" },
        { "fullPrompt": "A sculpture that looks like it could come to life", "shortPrompt": "Could come to life" },
        { "fullPrompt": "A piece that reminds you of a dream you once had", "shortPrompt": "Dreamlike piece" },
        { "fullPrompt": "An artwork with an animal you’d want as a pet", "shortPrompt": "Pet-worthy animal" },
        { "fullPrompt": "A piece that feels like it belongs in a fairytale", "shortPrompt": "Fairytale vibes" },
        { "fullPrompt": "An artwork that makes you feel calm", "shortPrompt": "Calm-inducing" },
        { "fullPrompt": "A piece that you think hides a story no one has uncovered yet", "shortPrompt": "Hidden story" },
        { "fullPrompt": "An artwork with more than five people in it", "shortPrompt": "Crowded artwork" },
        { "fullPrompt": "A piece that reminds you of your favorite memory", "shortPrompt": "Favorite memory" },
        { "fullPrompt": "An artwork you’d want to hang in your bedroom", "shortPrompt": "Bedroom piece" },
        { "fullPrompt": "A piece that makes you feel small", "shortPrompt": "Makes you feel small" },
        { "fullPrompt": "An artwork with a surprising texture", "shortPrompt": "Surprising texture" },
        { "fullPrompt": "A piece that seems out of place in the museum", "shortPrompt": "Out of place" },
        { "fullPrompt": "A piece that makes you feel powerful", "shortPrompt": "Empowering" },
        { "fullPrompt": "An artwork with a hidden detail you almost missed", "shortPrompt": "Hidden detail" },
        { "fullPrompt": "A piece that feels like it belongs in another time", "shortPrompt": "Belongs to another time" },
        { "fullPrompt": "An artwork you think would confuse its own artist", "shortPrompt": "Confusing for artist" },
        { "fullPrompt": "A piece that feels like a portal to another world", "shortPrompt": "Portal to another world" },
        { "fullPrompt": "An artwork that tells you everything about the artist", "shortPrompt": "Tells about artist" },
        { "fullPrompt": "A piece with a symbol you recognize", "shortPrompt": "Recognizable symbol" },
        { "fullPrompt": "An artwork that makes you want to learn more about its subject", "shortPrompt": "Learn about subject" },
        { "fullPrompt": "A piece that feels unfinished in the best way", "shortPrompt": "Beautifully unfinished" },
        { "fullPrompt": "An artwork that feels like music", "shortPrompt": "Musical vibes" }
      ]
      
      
};

export async function GET(req: NextRequest) {
	const { searchParams } = new URL(req.url);
	const set = searchParams.get("set") || "default";
	const prompts = promptSets[set] || [];
	return NextResponse.json(prompts);
}

export async function POST(req: NextRequest) {
	const { set, prompts } = await req.json();
	if (!set || !Array.isArray(prompts)) {
		return NextResponse.json({ error: "Invalid data" }, { status: 400 });
	}
	promptSets[set] = prompts;
	return NextResponse.json({ message: "Prompt set saved" });
}

================
File: app/api/uploads/route.ts
================
import { NextRequest, NextResponse } from "next/server";
import formidable, { Fields, Files } from "formidable";
import { promises as fsPromises } from "fs";
import path from "path";

// Ensure the uploads directory exists
const ensureUploadDir = async () => {
  const uploadDir = path.join(process.cwd(), "uploads");
  try {
    await fsPromises.mkdir(uploadDir, { recursive: true });
  } catch (err) {
    console.error("Error ensuring upload directory:", err);
  }
  return uploadDir;
};

// Parse multipart form data using formidable
const parseForm = async (req: NextRequest): Promise<{ fields: Fields; files: Files }> => {
  const uploadDir = await ensureUploadDir();

  const form = formidable({
    multiples: true, // Allow multiple files
    uploadDir, // Directory to save uploaded files
    keepExtensions: true, // Keep file extensions
  });

  return new Promise((resolve, reject) => {
    form.parse(req as any, (err, fields, files) => {
      if (err) reject(err);
      else resolve({ fields, files });
    });
  });
};

// POST endpoint to handle uploads
export async function POST(req: NextRequest) {
  try {
    const { files } = await parseForm(req);

    if (!files.images) {
      return NextResponse.json({ error: "No images uploaded" }, { status: 400 });
    }

    const uploadedFiles = Array.isArray(files.images)
      ? files.images
      : [files.images];

    // Collect file metadata
    const fileDetails = uploadedFiles.map((file) => ({
      filename: file.originalFilename,
      filepath: file.filepath,
    }));

    return NextResponse.json({
      message: "Images uploaded successfully",
      files: fileDetails,
    });
  } catch (error) {
    console.error("Error during file upload:", error);
    return NextResponse.json({ error: "File upload failed" }, { status: 500 });
  }
}

// Config to disable Next.js body parsing for this route
export const config = {
  api: {
    bodyParser: false,
  },
};

================
File: app/api/utils/multerConfig.ts
================
import multer from "multer";
import path from "path";

export const upload = multer({
    dest: path.join(__dirname, "../uploads"),
});

================
File: app/components/CameraModal.tsx
================
import React, { useState } from "react";
import {
	Box,
	Button,
	Dialog,
	DialogActions,
	DialogContent,
	Typography,
} from "@mui/material";

interface Prompt {
	fullPrompt: string;
	shortPrompt: string;
}

interface Tile {
	id: number;
	prompt: Prompt;
	completed: boolean;
	image: string | null;
	width: number;
	height: number;
}

interface CameraModalProps {
	tile: Tile;
	onClose: () => void;
	onSave: (
		id: number,
		image: string | null,
		orientation: "landscape" | "portrait"
	) => void;
}

const CameraModal: React.FC<CameraModalProps> = ({ tile, onClose, onSave }) => {
	const [image, setImage] = useState<string | null>(tile.image);

	const handleCapture = async (
		event: React.ChangeEvent<HTMLInputElement>
	) => {
		const file = event.target.files?.[0];
		if (file) {
			const url = URL.createObjectURL(file);

			// Determine orientation based on image dimensions
			const img = new Image();
			img.src = url;
			img.onload = () => {
				const orientation =
					img.width > img.height ? "landscape" : "portrait";
				setImage(url);
				onSave(tile.id, url, orientation);
			};
		}
	};

	const handleDelete = () => {
		setImage(null);
	};

	const handleSave = () => {
		if (image) {
			const orientation = "landscape"; // Assume default, as orientation is calculated on capture
			onSave(tile.id, image, orientation);
		}
	};

	return (
		<Dialog open onClose={onClose}>
			<DialogContent>
				<Typography variant="h6">{tile.prompt.fullPrompt}</Typography>
				<Box mt={2}>
					{image ? (
						<Box>
							<img
								src={image}
								alt="Preview"
								style={{ width: "100%", borderRadius: "4px" }}
							/>
							<Box
								display="flex"
								justifyContent="space-between"
								mt={2}
							>
								<Button
									variant="outlined"
									color="secondary"
									onClick={handleDelete}
								>
									Delete Image
								</Button>
							</Box>
						</Box>
					) : (
						<Button variant="contained" component="label">
							Upload or Take a Photo
							<input
								type="file"
								accept="image/*"
								hidden
								onChange={handleCapture}
							/>
						</Button>
					)}
				</Box>
			</DialogContent>
			<DialogActions>
				<Button onClick={onClose}>Cancel</Button>
				<Button onClick={handleSave} disabled={!image}>
					Save
				</Button>
			</DialogActions>
		</Dialog>
	);
};

export default CameraModal;

================
File: app/components/PromptGrid.tsx
================
import React, { useState, useEffect } from "react";
import { Box, Button, Typography, Grid } from "@mui/material";
import CameraModal from "./CameraModal";
import { fetchPrompts } from "../services/api";

interface Tile {
	id: number;
	prompt: string;
	completed: boolean;
	image: string | null;
}

const PromptGrid: React.FC = () => {
	const [tiles, setTiles] = useState<Tile[]>([]);
	const [activeTile, setActiveTile] = useState<Tile | null>(null);

	useEffect(() => {
		const loadPrompts = async () => {
			const prompts = await fetchPrompts("default");
			setTiles(
				prompts.map((prompt: string, idx: number) => ({
					id: idx,
					prompt,
					completed: false,
					image: null,
				}))
			);
		};
		loadPrompts();
	}, []);

	const markTileCompleted = (id: number, image: string | null) => {
		setTiles((prevTiles) =>
			prevTiles.map((tile) =>
				tile.id === id ? { ...tile, completed: !!image, image } : tile
			)
		);
		setActiveTile(null);
	};

	return (
		<Box p={4}>
			<Typography variant="h4" gutterBottom>
				SnapQuest: Bingo
			</Typography>
			<Grid container spacing={2}>
				{tiles.map((tile) => (
					<Grid item xs={4} key={tile.id}>
						<Button
							fullWidth
							variant={tile.completed ? "contained" : "outlined"}
							color={tile.completed ? "success" : "primary"}
							onClick={() => setActiveTile(tile)}
						>
							{tile.prompt}
						</Button>
					</Grid>
				))}
			</Grid>
			{activeTile && (
				<CameraModal
					tile={activeTile}
					onClose={() => setActiveTile(null)}
					onSave={markTileCompleted}
				/>
			)}
		</Box>
	);
};

export default PromptGrid;

================
File: app/services/api.ts
================
import apiClient from "./apiClient";

interface Prompt {
    fullPrompt: string;
    shortPrompt: string;
  }

export const fetchPrompts = async (set: string): Promise<Prompt[]> => {
    const response = await apiClient.get(`/prompts`, { params: { set } });
    return response.data;
  };
  

export const uploadPhoto = async (file: File): Promise<string> => {
    const formData = new FormData();
    formData.append("photo", file);

    const response = await apiClient.post(`/uploads`, formData, {
        headers: { "Content-Type": "multipart/form-data" },
    });

    return response.data.url; // Return uploaded image URL
};

================
File: app/services/apiClient.ts
================
import axios from "axios";

const apiClient = axios.create({
    baseURL: "/api", // Relative path for Vercel
    timeout: 5000,   // Timeout for requests
});

export default apiClient;

================
File: app/services/db.ts
================
// db.ts
import Dexie from "dexie";

export interface Photo {
    id: number;
    image: string;
}

class SnapQuestDB extends Dexie {
    photos!: Dexie.Table<Photo, number>;

    constructor() {
        super("SnapQuestDB");
        this.version(1).stores({
            photos: "++id, image",
        });
    }
}

export const db = new SnapQuestDB();

================
File: app/services/pdfGenerator.ts
================
import { PDFDocument, rgb } from "pdf-lib";

const PAGE_WIDTH = 600;
const PAGE_HEIGHT = 800;
const MARGIN = 50;
const ROW_HEIGHT = 120; // Space for one row of image and text
const IMAGE_WIDTH = 100;
const IMAGE_HEIGHT = 100;

export const generatePDF = async (title: string, tiles: { prompt: string; image: string | null }[]) => {
  const pdfDoc = await PDFDocument.create();

  let page = pdfDoc.addPage([PAGE_WIDTH, PAGE_HEIGHT]);
  let yPosition = PAGE_HEIGHT - MARGIN;

  page.drawText(title, {
    x: MARGIN,
    y: yPosition,
    size: 24,
    color: rgb(0, 0.53, 0.71),
  });

  yPosition -= 40; // Move down after title

  for (const tile of tiles) {
    if (yPosition < MARGIN + ROW_HEIGHT) {
      page = pdfDoc.addPage([PAGE_WIDTH, PAGE_HEIGHT]);
      yPosition = PAGE_HEIGHT - MARGIN;
    }

    page.drawText(tile.prompt, {
      x: MARGIN + IMAGE_WIDTH + 10,
      y: yPosition - IMAGE_HEIGHT / 2,
      size: 12,
      color: rgb(0, 0, 0),
    });

    if (tile.image) {
      const imageBytes = await fetch(tile.image).then((res) => res.arrayBuffer());
      const jpgImage = await pdfDoc.embedJpg(imageBytes);
      page.drawImage(jpgImage, {
        x: MARGIN,
        y: yPosition - IMAGE_HEIGHT,
        width: IMAGE_WIDTH,
        height: IMAGE_HEIGHT,
      });
    }

    yPosition -= ROW_HEIGHT; // Move down for the next row
  }

  const pdfBytes = await pdfDoc.save();
  return new Blob([pdfBytes], { type: "application/pdf" });
};

================
File: app/services/zipImages.ts
================
import JSZip from "jszip";
import { saveAs } from "file-saver";

interface Prompt {
	fullPrompt: string;
	shortPrompt: string;
}

interface Tile {
	id: number;
	prompt: Prompt;
	completed: boolean;
	image: string | null;
	width: number; // Mosaic dimensions
	height: number;
}

export const downloadImagesAsZip = async (tiles: Tile[]) => {
	const zip = new JSZip();

	for (const [index, tile] of tiles.entries()) {
		if (tile.image) {
			const imageBlob = await fetch(tile.image).then((res) => res.blob());
			zip.file(`image-${index + 1}.jpg`, imageBlob);
		}
	}

	const zipBlob = await zip.generateAsync({ type: "blob" });
	saveAs(zipBlob, "snapquest-images.zip");
};

================
File: app/app.css
================
/* Global Dark Theme */
body {
	background-color: #121212;
	color: #e0e0e0;
	font-family: Arial, sans-serif;
	margin: 0;
	padding: 0;
}

.dark-theme {
	background-color: #121212;
	color: #e0e0e0;
}

.title {
	text-align: center;
	font-weight: bold;
	color: #ffffff;
}

.prompt-set-title {
	text-align: left;
	font-weight: bold;
	color: #ffffff;
}

/* Mosaic Grid */
.mosaic-grid {
	display: flex;
	flex-wrap: wrap;
	gap: 10px;
}

.mosaic-tile {
	display: flex;
	justify-content: center;
	align-items: center;
	background-color: #333333;
	border: 1px solid #444444;
	border-radius: 10px;
	cursor: pointer;
	text-align: center;
	overflow: hidden;
	color: #e0e0e0;
}

.mosaic-tile:hover {
	border-color: #777777;
	background-color: #444444;
}

/* Fixed Download Buttons */
.download-buttons {
	position: fixed;
	bottom: 20px;
	left: 50%;
	transform: translateX(-50%);
	display: flex;
	gap: 10px;
}

================
File: app/globals.css
================
:root {
  --background: #ffffff;
  --foreground: #171717;
}

@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }
}

html,
body {
  max-width: 100vw;
  overflow-x: hidden;
}

body {
  color: var(--foreground);
  background: var(--background);
  font-family: Arial, Helvetica, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

* {
  box-sizing: border-box;
  padding: 0;
  margin: 0;
}

a {
  color: inherit;
  text-decoration: none;
}

@media (prefers-color-scheme: dark) {
  html {
    color-scheme: dark;
  }
}

================
File: app/layout.tsx
================
import type { Metadata } from "next";
import localFont from "next/font/local";
import "./globals.css";

const geistSans = localFont({
  src: "./fonts/GeistVF.woff",
  variable: "--font-geist-sans",
  weight: "100 900",
});
const geistMono = localFont({
  src: "./fonts/GeistMonoVF.woff",
  variable: "--font-geist-mono",
  weight: "100 900",
});

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body className={`${geistSans.variable} ${geistMono.variable}`}>
        {children}
      </body>
    </html>
  );
}

================
File: app/page.module.css
================
.page {
  --gray-rgb: 0, 0, 0;
  --gray-alpha-200: rgba(var(--gray-rgb), 0.08);
  --gray-alpha-100: rgba(var(--gray-rgb), 0.05);

  --button-primary-hover: #383838;
  --button-secondary-hover: #f2f2f2;

  display: grid;
  grid-template-rows: 20px 1fr 20px;
  align-items: center;
  justify-items: center;
  min-height: 100svh;
  padding: 80px;
  gap: 64px;
  font-family: var(--font-geist-sans);
}

@media (prefers-color-scheme: dark) {
  .page {
    --gray-rgb: 255, 255, 255;
    --gray-alpha-200: rgba(var(--gray-rgb), 0.145);
    --gray-alpha-100: rgba(var(--gray-rgb), 0.06);

    --button-primary-hover: #ccc;
    --button-secondary-hover: #1a1a1a;
  }
}

.main {
  display: flex;
  flex-direction: column;
  gap: 32px;
  grid-row-start: 2;
}

.main ol {
  font-family: var(--font-geist-mono);
  padding-left: 0;
  margin: 0;
  font-size: 14px;
  line-height: 24px;
  letter-spacing: -0.01em;
  list-style-position: inside;
}

.main li:not(:last-of-type) {
  margin-bottom: 8px;
}

.main code {
  font-family: inherit;
  background: var(--gray-alpha-100);
  padding: 2px 4px;
  border-radius: 4px;
  font-weight: 600;
}

.ctas {
  display: flex;
  gap: 16px;
}

.ctas a {
  appearance: none;
  border-radius: 128px;
  height: 48px;
  padding: 0 20px;
  border: none;
  border: 1px solid transparent;
  transition:
    background 0.2s,
    color 0.2s,
    border-color 0.2s;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 16px;
  line-height: 20px;
  font-weight: 500;
}

a.primary {
  background: var(--foreground);
  color: var(--background);
  gap: 8px;
}

a.secondary {
  border-color: var(--gray-alpha-200);
  min-width: 180px;
}

.footer {
  grid-row-start: 3;
  display: flex;
  gap: 24px;
}

.footer a {
  display: flex;
  align-items: center;
  gap: 8px;
}

.footer img {
  flex-shrink: 0;
}

/* Enable hover only on non-touch devices */
@media (hover: hover) and (pointer: fine) {
  a.primary:hover {
    background: var(--button-primary-hover);
    border-color: transparent;
  }

  a.secondary:hover {
    background: var(--button-secondary-hover);
    border-color: transparent;
  }

  .footer a:hover {
    text-decoration: underline;
    text-underline-offset: 4px;
  }
}

@media (max-width: 600px) {
  .page {
    padding: 32px;
    padding-bottom: 80px;
  }

  .main {
    align-items: center;
  }

  .main ol {
    text-align: center;
  }

  .ctas {
    flex-direction: column;
  }

  .ctas a {
    font-size: 14px;
    height: 40px;
    padding: 0 16px;
  }

  a.secondary {
    min-width: auto;
  }

  .footer {
    flex-wrap: wrap;
    align-items: center;
    justify-content: center;
  }
}

@media (prefers-color-scheme: dark) {
  .logo {
    filter: invert();
  }
}

================
File: app/page.tsx
================
"use client";

import React, { useState, useEffect } from "react";
import { Box, Typography, Grid, Button } from "@mui/material";
import CameraModal from "./components/CameraModal";
import { fetchPrompts } from "./services/api";
import { generatePDF } from "./services/pdfGenerator";
import { downloadImagesAsZip } from "./services/zipImages";
import "./app.css"; // For dark theme and custom styling

interface Prompt {
	fullPrompt: string;
	shortPrompt: string;
}

interface Tile {
	id: number;
	prompt: Prompt;
	completed: boolean;
	image: string | null;
	width: number; // Mosaic dimensions
	height: number;
}

const App: React.FC = () => {
	const [tiles, setTiles] = useState<Tile[]>([]);
	const [activeTile, setActiveTile] = useState<Tile | null>(null);
	const [promptSet, setPromptSet] = useState("Select..."); // Track the selected prompt set
	const [isGeneratingPDF, setIsGeneratingPDF] = useState(false);
	const [isDownloadingImages, setIsDownloadingImages] = useState(false);

	// Load prompts dynamically from the server
	useEffect(() => {
		const loadPrompts = async () => {
			try {
				const prompts = await fetchPrompts(promptSet);
				setTiles(
					prompts.map((prompt: Prompt, idx: number) => ({
						id: idx,
						prompt,
						completed: false,
						image: null,
						width: 1, // Default mosaic size
						height: 1,
					}))
				);
			} catch (error) {
				console.error("Failed to load prompts:", error);
			}
		};
		loadPrompts();
	}, [promptSet]);

	// Open Camera Modal when a tile is clicked
	const handleTileClick = (tile: Tile) => {
		setActiveTile(tile);
	};

	// Update a tile's image and resize dynamically for the mosaic
	const updateTileImage = (
		id: number,
		image: string | null,
		orientation: "landscape" | "portrait"
	) => {
		setTiles((prevTiles) =>
			prevTiles.map((tile) => {
				if (tile.id === id) {
					const newSize = calculateMosaicSize(orientation);
					return { ...tile, completed: !!image, image, ...newSize };
				}
				return tile;
			})
		);
		setActiveTile(null);
	};

	// Generate mosaic sizes dynamically based on image orientation
	const calculateMosaicSize = (orientation: "landscape" | "portrait") => {
		if (orientation === "portrait") {
			return { width: 1, height: Math.random() > 0.5 ? 2 : 1 }; // 1x1 or 1x2
		} else {
			return { width: Math.random() > 0.5 ? 2 : 1, height: 1 }; // 1x1 or 2x1
		}
	};

	// Generate and download the PDF
	const downloadPDF = async () => {
		try {
			setIsGeneratingPDF(true);
			const pdfBlob = await generatePDF(
				"SnapQuest: " + promptSet,
				tiles.map((tile) => ({
					prompt: tile.prompt.fullPrompt,
					image: tile.image,
					width: tile.width,
					height: tile.height,
				}))
			);
			const url = URL.createObjectURL(pdfBlob);
			const link = document.createElement("a");
			link.href = url;
			link.download = "snapquest-bingo.pdf";
			link.click();
			URL.revokeObjectURL(url);
		} catch (error) {
			console.error("Failed to generate PDF:", error);
		} finally {
			setIsGeneratingPDF(false);
		}
	};

	// Download all images as a zip file
	const downloadImages = async () => {
		try {
			setIsDownloadingImages(true);
			await downloadImagesAsZip(tiles);
		} catch (error) {
			console.error("Failed to download images:", error);
		} finally {
			setIsDownloadingImages(false);
		}
	};

	return (
		<Box className="dark-theme" p={4}>
			<Typography variant="h3" gutterBottom className="title">
				SnapQuest
			</Typography>

			{/* Dropdown for prompt set selection */}
			{
				<Box
					mb={2}
					style={{
						display: "flex",
						gap: "10px",
                        alignItems: "center",
					}}
				>
					{promptSet === "Select..." ? (
						<Typography>Select a Prompt Set:</Typography>
					) : (
						<Typography
							variant="h4"
							gutterBottom
							className="prompt-set-title"
						>
							{promptSet.slice(0, 1).toUpperCase() +
								promptSet.slice(1)}
						</Typography>
					)}
					<select
						value={promptSet}
						onChange={(e) => setPromptSet(e.target.value)}
						style={{
                            padding: "0.25rem",
                            marginTop: "0.25rem",
                            marginBottom: "1rem"
                        }}
					>
						<option value="select">Select...</option>
						<option value="books">Books</option>
						<option value="art">Art</option>
					</select>
				</Box>
			}

			{/* Render the mosaic grid */}
			<Grid container spacing={2} className="mosaic-grid">
				{tiles.map((tile) => (
					<Grid
						item
						key={tile.id}
						xs={tile.width * 2} // Adjust grid size dynamically
						sm={tile.width * 2}
						style={{
							aspectRatio: `${tile.width} / ${tile.height}`,
							background: tile.image
								? `url(${tile.image})`
								: "none",
							backgroundSize: "cover",
							backgroundPosition: "center",
							color: tile.image ? "white" : "inherit",
						}}
						className="mosaic-tile"
						onClick={() => handleTileClick(tile)}
					>
						{tile.image
							? ""
							: tile.prompt.shortPrompt || tile.prompt.fullPrompt}
					</Grid>
				))}
			</Grid>

			{/* Modal for capturing/uploading images */}
			{activeTile && (
				<CameraModal
					tile={activeTile}
					onClose={() => setActiveTile(null)}
					onSave={(id, image, orientation) =>
						updateTileImage(id, image, orientation)
					}
				/>
			)}

			{/* Fixed download buttons */}
			<Box className="download-buttons">
				<Button
					variant="contained"
					color="primary"
					onClick={downloadPDF}
					disabled={isGeneratingPDF}
				>
					{isGeneratingPDF ? "Generating PDF..." : "Download PDF"}
				</Button>
				<Button
					variant="contained"
					color="secondary"
					onClick={downloadImages}
					disabled={isDownloadingImages}
				>
					{isDownloadingImages ? "Downloading..." : "Download Images"}
				</Button>
			</Box>
		</Box>
	);
};

export default App;

================
File: .gitignore
================
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*
.next

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

================
File: eslint.config.js
================
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'

export default tseslint.config(
  { ignores: ['dist'] },
  {
    extends: [js.configs.recommended, ...tseslint.configs.recommended],
    files: ['**/*.{ts,tsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...reactHooks.configs.recommended.rules,
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
)

================
File: index.html
================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + React + TS</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>

================
File: next-env.d.ts
================
/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/building-your-application/configuring/typescript for more information.

================
File: next.config.ts
================
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
	reactStrictMode: true,
	// Make sure this is not changed to 'dist' or another value
	
};

export default nextConfig;

================
File: package.json
================
{
  "name": "snap-quest",
  "version": "0.1.0",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@emotion/react": "^11.13.5",
    "@emotion/styled": "^11.13.5",
    "@mui/material": "^6.1.8",
    "@vitejs/plugin-react": "^4.3.4",
    "axios": "^1.7.8",
    "dexie": "^4.0.10",
    "express": "^4.21.1",
    "file-saver": "^2.0.5",
    "formidable": "^3.5.2",
    "jszip": "^3.10.1",
    "next": "^15.0.3",
    "pdf-lib": "^1.17.1",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "typescript-eslint": "^8.16.0",
    "vite": "^6.0.1"
  },
  "devDependencies": {
    "@types/express": "^5.0.0",
    "@types/file-saver": "^2.0.7",
    "@types/formidable": "^3.4.5",
    "@types/multer": "^1.4.12",
    "@types/node": "^20",
    "@types/react": "^18",
    "@types/react-dom": "^18",
    "eslint": "^9.15.0",
    "eslint-config-react": "^1.1.7",
    "eslint-plugin-react-hooks": "^5.0.0",
    "eslint-plugin-react-refresh": "^0.4.14",
    "typescript": "^5"
  }
}

================
File: README.md
================
# React + TypeScript + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react/README.md) uses [Babel](https://babeljs.io/) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## Expanding the ESLint configuration

If you are developing a production application, we recommend updating the configuration to enable type aware lint rules:

- Configure the top-level `parserOptions` property like this:

```js
export default tseslint.config({
  languageOptions: {
    // other options...
    parserOptions: {
      project: ['./tsconfig.node.json', './tsconfig.app.json'],
      tsconfigRootDir: import.meta.dirname,
    },
  },
})
```

- Replace `tseslint.configs.recommended` to `tseslint.configs.recommendedTypeChecked` or `tseslint.configs.strictTypeChecked`
- Optionally add `...tseslint.configs.stylisticTypeChecked`
- Install [eslint-plugin-react](https://github.com/jsx-eslint/eslint-plugin-react) and update the config:

```js
// eslint.config.js
import react from 'eslint-plugin-react'

export default tseslint.config({
  // Set the react version
  settings: { react: { version: '18.3' } },
  plugins: {
    // Add the react plugin
    react,
  },
  rules: {
    // other rules...
    // Enable its recommended rules
    ...react.configs.recommended.rules,
    ...react.configs['jsx-runtime'].rules,
  },
})
```

================
File: tsconfig.app.json
================
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "Bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"]
}

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": [
      "dom",
      "dom.iterable",
      "esnext"
    ],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": [
        "./*"
      ]
    }
  },
  "include": [
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts",
    "next-env.d.ts",
    "dist/types/**/*.ts"
  ],
  "exclude": [
    "node_modules"
  ]
}

================
File: tsconfig.node.json
================
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2022",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "Bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}

================
File: vite.config.ts
================
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
})
