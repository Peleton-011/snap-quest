This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-18T18:23:46.250Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
app/
  api/
    promptSets/
      [id]/
        route.ts
      route.ts
    uploads/
      route.ts
  components/
    CameraModal.tsx
  services/
    api.ts
    apiClient.ts
    db.ts
    pdfGenerator.ts
    zipImages.ts
  types/
    types.ts
  app.css
  globals.css
  layout.tsx
  page.module.css
  page.tsx
  theme.ts
.gitignore
eslint.config.js
index.html
mongotest.cjs
mongoUpload.cjs
next-env.d.ts
next.config.ts
package.json
README.md
tsconfig.app.json
tsconfig.json
tsconfig.node.json
vite.config.ts

================================================================
Repository Files
================================================================

================
File: app/api/promptSets/[id]/route.ts
================
import { NextRequest, NextResponse } from "next/server";
import { MongoClient, ServerApiVersion, ObjectId } from "mongodb";

const uri = process.env.MONGODB_URI || "";

console.log(uri);
const client = new MongoClient(uri, {
	serverApi: {
		version: ServerApiVersion.v1,
		strict: true,
		deprecationErrors: true,
	},
	tls: true,
});

export async function GET(
	req: NextRequest,
	{ params }: { params: { id: string } }
) {
	try {
		await client.connect();
		const db = client.db("promptsDB");
		const promptSetsCollection = db.collection("promptSets");
		const promptsCollection = db.collection("prompts");

		const { id } = params;

		if (!id) {
			return NextResponse.json(
				{ error: "Missing '_id' parameter" },
				{ status: 400 }
			);
		}

		// Convert string ID to ObjectId
		const objectId = new ObjectId(id);

		// Use aggregation to match and dereference prompts
		const result = await promptSetsCollection
			.aggregate([
				{ $match: { _id: objectId } }, // Match the specific PromptSet by _id
				{
					$lookup: {
						from: "prompts", // Reference the prompts collection
						localField: "prompts", // The array of references in promptSets
						foreignField: "_id", // The field in the prompts collection to match
						as: "prompts", // Name the resulting array in the output
					},
				},
			])
			.toArray();

		if (result.length === 0) {
			return NextResponse.json(
				{ error: "No PromptSet found with the given _id" },
				{ status: 404 }
			);
		}

		// Return the single matching PromptSet
		return NextResponse.json(result[0]);
	} catch (error) {
		console.error("Error fetching promptSet:", error);
		return NextResponse.json(
			{ error: "Failed to fetch promptSet" },
			{ status: 500 }
		);
	} finally {
		await client.close(); // Ensure the client is closed after the request
	}
}

================
File: app/api/promptSets/route.ts
================
import { NextRequest, NextResponse } from "next/server";
import { PromptSet, Prompt } from "@/app/types/types";
import { MongoClient, ServerApiVersion } from "mongodb";

const uri = process.env.MONGODB_URI || "";

const client = new MongoClient(uri, {
	serverApi: {
		version: ServerApiVersion.v1,
		strict: true,
		deprecationErrors: true,
	},
});


export async function GET(req: NextRequest) {
	const { searchParams } = new URL(req.url);
	const set = searchParams.get("set") || "default";

	// Fetch promptSets from mongoDB

	try {
		await client.connect();
		const db = client.db("promptsDB");
		const promptSetsCollection = db.collection<PromptSet>("promptSets");
		const promptSets = await promptSetsCollection.find({}, { projection: { _id: 1, name: 1, description: 1} }).toArray();
		return NextResponse.json(promptSets);
	} catch (error) {
		console.error("Error fetching promptSets:", error);
	}
}

================
File: app/api/uploads/route.ts
================
import { NextRequest, NextResponse } from "next/server";
import formidable, { Fields, Files } from "formidable";
import { promises as fsPromises } from "fs";
import path from "path";

// Ensure the uploads directory exists
const ensureUploadDir = async () => {
  const uploadDir = path.join(process.cwd(), "uploads");
  try {
    await fsPromises.mkdir(uploadDir, { recursive: true });
  } catch (err) {
    console.error("Error ensuring upload directory:", err);
  }
  return uploadDir;
};

// Parse multipart form data using formidable
const parseForm = async (req: NextRequest): Promise<{ fields: Fields; files: Files }> => {
  const uploadDir = await ensureUploadDir();

  const form = formidable({
    multiples: true, // Allow multiple files
    uploadDir, // Directory to save uploaded files
    keepExtensions: true, // Keep file extensions
  });

  return new Promise((resolve, reject) => {
    form.parse(req as any, (err, fields, files) => {
      if (err) reject(err);
      else resolve({ fields, files });
    });
  });
};

// POST endpoint to handle uploads
export async function POST(req: NextRequest) {
  try {
    const { files } = await parseForm(req);

    if (!files.images) {
      return NextResponse.json({ error: "No images uploaded" }, { status: 400 });
    }

    const uploadedFiles = Array.isArray(files.images)
      ? files.images
      : [files.images];

    // Collect file metadata
    const fileDetails = uploadedFiles.map((file) => ({
      filename: file.originalFilename,
      filepath: file.filepath,
    }));

    return NextResponse.json({
      message: "Images uploaded successfully",
      files: fileDetails,
    });
  } catch (error) {
    console.error("Error during file upload:", error);
    return NextResponse.json({ error: "File upload failed" }, { status: 500 });
  }
}

// Config to disable Next.js body parsing for this route
export const config = {
  api: {
    bodyParser: false,
  },
};

================
File: app/components/CameraModal.tsx
================
import React, { useState } from "react";
import {
	Box,
	Button,
	Dialog,
	DialogActions,
	DialogContent,
	Typography,
} from "@mui/material";

import {Prompt, Tile } from "@/app/types/types"

interface CameraModalProps {
	tile: Tile;
	onClose: () => void;
	onSave: (
		id: number,
		image: string | null,
		orientation: "landscape" | "portrait"
	) => void;
    language: string;
}

const CameraModal: React.FC<CameraModalProps> = ({ tile, onClose, onSave, language }) => {
	const [image, setImage] = useState<string | null>(tile.image);

	const handleCapture = async (
		event: React.ChangeEvent<HTMLInputElement>
	) => {
		const file = event.target.files?.[0];
		if (file) {
			const url = URL.createObjectURL(file);

			// Determine orientation based on image dimensions
			const img = new Image();
			img.src = url;
			img.onload = () => {
				const orientation =
					img.width > img.height ? "landscape" : "portrait";
				setImage(url);
				onSave(tile.id, url, orientation);
			};
		}
	};

	const handleDelete = () => {
		setImage(null);
	};

	const handleSave = () => {
		if (image) {
			const orientation = "landscape"; // Assume default, as orientation is calculated on capture
			onSave(tile.id, image, orientation);
		}
	};

	return (
		<Dialog open onClose={onClose}>
			<DialogContent className="modal">
				<Typography variant="h6">{tile.prompt.fullPrompt[language]}</Typography>
				<Box mt={2}>
					{image && (
						<Box>
							<img
								src={image}
								alt="Preview"
								style={{ width: "100%", borderRadius: "4px" }}
							/>
							<Box
								display="flex"
								justifyContent="space-between"
								mt={2}
							>
								<Button
									variant="outlined"
									color="secondary"
									onClick={handleDelete}
								>
									Delete Image
								</Button>
							</Box>
						</Box>
					)}
				</Box>
			</DialogContent>
			<DialogActions className="modal">
				{!image && (
					<Button variant="contained" component="label">
						Upload or Take a Photo
						<input
							type="file"
							accept="image/*"
							hidden
							onChange={handleCapture}
						/>
					</Button>
				)}
				<Button onClick={onClose}>Cancel</Button>
				<Button onClick={handleSave} disabled={!image}>
					Save
				</Button>
			</DialogActions>
		</Dialog>
	);
};

export default CameraModal;

================
File: app/services/api.ts
================
import apiClient from "./apiClient";
import { Prompt, PromptSet } from "@/app/types/types";

export const fetchPromptSets = async (): Promise<PromptSet[]> => {
	const response = await apiClient.get(`/promptSets`);
	return response.data;
};
export const fetchPrompts = async (id: string): Promise<Prompt[]> => {
	const response = await apiClient.get(`/promptSets/${id}`);
	return response.data.prompts;
};

export const uploadPhoto = async (file: File): Promise<string> => {
	const formData = new FormData();
	formData.append("photo", file);

	const response = await apiClient.post(`/uploads`, formData, {
		headers: { "Content-Type": "multipart/form-data" },
	});

	return response.data.url; // Return uploaded image URL
};

================
File: app/services/apiClient.ts
================
import axios from "axios";

const apiClient = axios.create({
    baseURL: "/api", // Relative path for Vercel
    timeout: 5000,   // Timeout for requests
});

export default apiClient;

================
File: app/services/db.ts
================
// db.ts
import Dexie from "dexie";

export interface Photo {
    id: number;
    image: string;
}

class SnapQuestDB extends Dexie {
    photos!: Dexie.Table<Photo, number>;

    constructor() {
        super("SnapQuestDB");
        this.version(1).stores({
            photos: "++id, image",
        });
    }
}

export const db = new SnapQuestDB();

================
File: app/services/pdfGenerator.ts
================
import { PDFDocument, rgb, StandardFonts } from "pdf-lib";

// Define constants for the PDF page size, margins, and minimum row height
const PAGE_WIDTH = 600;
const PAGE_HEIGHT = 800;
const MARGIN = 50;
const MIN_ROW_HEIGHT = 150; // Minimum height for each row (space for image and prompt)

// Define theme colors based on the app's dark theme
const PRIMARY_COLOR = rgb(0.341, 0.89, 0.537); // #57e389 (Primary color)
const BACKGROUND_COLOR = rgb(0.071, 0.071, 0.071); // #121212 (Dark background color)
const FOREGROUND_COLOR = rgb(1, 1, 1); // #ffffff (Primary text color)

export async function generatePDF(
	title: string,
	tiles: { prompt: string; image: string | null }[]
) {
	const pdfDoc = await PDFDocument.create();
	let page = pdfDoc.addPage([PAGE_WIDTH, PAGE_HEIGHT]);
	const boldFont = await pdfDoc.embedFont(StandardFonts.HelveticaBold);
	let yPosition = PAGE_HEIGHT - MARGIN;

	// Function to draw the background on a page
	const drawBackground = (page: any) => {
		page.drawRectangle({
			x: 0,
			y: 0,
			width: PAGE_WIDTH,
			height: PAGE_HEIGHT,
			color: BACKGROUND_COLOR,
		});
	};

	// Function to add a new page and reset `yPosition`
	const addNewPage = () => {
		page = pdfDoc.addPage([PAGE_WIDTH, PAGE_HEIGHT]);
		drawBackground(page);
		yPosition = PAGE_HEIGHT - MARGIN;
	};

	// Function to draw images and prompts
	const drawImages = async () => {
		let xPosition = MARGIN;
		let rowHeight = 0;

		for (let tile of tiles) {
			const image = tile.image;
			const prompt = tile.prompt;

			if (image) {
				// Fetch and embed image
				const imageBytes = await fetch(image).then((res) =>
					res.arrayBuffer()
				);
				const imageObj = await pdfDoc.embedJpg(imageBytes);
				const { width, height } = imageObj;
				const aspectRatio = width / height;

				// Limit the image size to fit within max dimensions
				const maxDimension = 250;
				let imgWidth = width;
				let imgHeight = height;

				if (imgWidth > maxDimension) {
					imgWidth = maxDimension;
					imgHeight = imgWidth / aspectRatio;
				}

				if (imgHeight > maxDimension) {
					imgHeight = maxDimension;
					imgWidth = imgHeight * aspectRatio;
				}

				const totalHeight = imgHeight + 30; // Image height + space for prompt

				// Check if there's space for the image and prompt
				if (yPosition - totalHeight < MARGIN) {
					addNewPage();
					xPosition = MARGIN;
					rowHeight = 0;
				}

				// Check if the image fits horizontally
				if (xPosition + imgWidth + MARGIN > PAGE_WIDTH) {
					xPosition = MARGIN;
					yPosition -= rowHeight; // Move yPosition down by the row height
					rowHeight = 0;

					// Check again if there's enough vertical space
					if (yPosition - totalHeight < MARGIN) {
						addNewPage();
						xPosition = MARGIN;
					}
				}

				// Draw the image
				page.drawImage(imageObj, {
					x: xPosition,
					y: yPosition - imgHeight,
					width: imgWidth,
					height: imgHeight,
				});

				// Draw the prompt below the image
				page.drawText(prompt, {
					x: xPosition,
					y: yPosition - imgHeight - 15,
					size: 12,
					color: FOREGROUND_COLOR,
					maxWidth: imgWidth,
					lineHeight: 14,
				});

				// Update rowHeight and xPosition
				rowHeight = Math.max(rowHeight, totalHeight);
				xPosition += imgWidth + MARGIN;
			}
		}

		yPosition -= rowHeight; // Final adjustment after all rows
	};

	// Draw the background for the first page
	drawBackground(page);

	// Add the title to the first page
	page.drawText(title, {
		x: MARGIN,
		y: yPosition,
		size: 24,
		color: PRIMARY_COLOR,
		font: boldFont,
	});

	yPosition -= 40; // Space after the title

	// Draw images and prompts
	await drawImages();

	// Finalize the PDF
	const pdfBytes = await pdfDoc.save();
	return new Blob([pdfBytes], { type: "application/pdf" });
}

================
File: app/services/zipImages.ts
================
import JSZip from "jszip";
import { saveAs } from "file-saver";
import {Prompt, Tile} from "@/app/types/types"

export const downloadImagesAsZip = async (tiles: Tile[]) => {
	const zip = new JSZip();

	for (const [index, tile] of tiles.entries()) {
		if (tile.image) {
			const imageBlob = await fetch(tile.image).then((res) => res.blob());
			zip.file(`image-${index + 1}.jpg`, imageBlob);
		}
	}

	const zipBlob = await zip.generateAsync({ type: "blob" });
	saveAs(zipBlob, "snapquest-images.zip");
};

================
File: app/types/types.ts
================
export interface Prompt {
	fullPrompt: { [key: string]: string };
	shortPrompt: { [key: string]: string };
}

export interface PromptSet {
	_id?: string;
	name: string;
	prompts: Prompt[];
	description?: string;
}

export interface Tile {
	id: number;
	prompt: Prompt;
	completed: boolean;
	image: string | null;
	width: number;
	height: number;
}

================
File: app/app.css
================
/* Global Dark Theme */
body {
	color: #e0e0e0;
	font-family: Arial, sans-serif;
	margin: 0;
	padding: 0;
}

.dark-theme {
	color: #e0e0e0;
}

.title {
	text-align: center;
	font-weight: bold;
	color: #24935b;
}

.prompt-set-title {
	text-align: left;
	font-weight: bold;
	color: #ffffff;
}

/* Mosaic Grid */
.mosaic-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
    gap: 20px; /* Space between tiles and prompts */
}

.mosaic-tile {
    position: relative;
    background-color: #333;
    border-radius: 8px;
    border: 2px solid #e0e0e0;
    cursor: pointer;
    width: 100%;
    aspect-ratio: 1; /* Maintain square aspect ratio */
}

.mosaic-tile.completed {
    border-color: #4caf50;
    cursor: default;
}

.prompt-label {
    text-align: center;
    font-size: 0.85rem;
    color: #6c757d;
    margin-top: -10px; /* Space between tile and prompt */
    word-break: break-word; /* Handle long text */
}


.mosaic-tile:hover {
	border-color: #777777;
	background-color: #444444;
}

/* Fixed Download Buttons */
.download-buttons {
	position: fixed;
	bottom: 20px;
	left: 50%;
	transform: translateX(-50%);
	display: flex;
	gap: 10px;
}

.modal {
    padding: 1rem;
}

================
File: app/globals.css
================
:root {
	--background: #181a1b;
	--foreground: #e8e6e3;
}

/* @media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }
} */

html,
body {
	max-width: 100vw;
	overflow-x: hidden;
}

body {
	color: var(--foreground);
	background: var(--background);
	font-family: Arial, Helvetica, sans-serif;
	-webkit-font-smoothing: antialiased;
	-moz-osx-font-smoothing: grayscale;
}

* {
	box-sizing: border-box;
	padding: 0;
	margin: 0;
}

a {
	color: inherit;
	text-decoration: none;
}

@media (prefers-color-scheme: dark) {
	html {
		color-scheme: dark;
	}
}

================
File: app/layout.tsx
================
import type { Metadata } from "next";
import localFont from "next/font/local";
import "./globals.css";


const geistSans = localFont({
	src: "./fonts/GeistVF.woff",
	variable: "--font-geist-sans",
	weight: "100 900",
});
const geistMono = localFont({
	src: "./fonts/GeistMonoVF.woff",
	variable: "--font-geist-mono",
	weight: "100 900",
});

export const metadata: Metadata = {
	title: "Create Next App",
	description: "Generated by create next app",
};

export default function RootLayout({
	children,
}: Readonly<{
	children: React.ReactNode;
}>) {
	return (
        <html lang="en">
				<body className={`${geistSans.variable} ${geistMono.variable}`}>
					{children}
				</body>
			</html>
	);
}

================
File: app/page.module.css
================
.page {
  --gray-rgb: 0, 0, 0;
  --gray-alpha-200: rgba(var(--gray-rgb), 0.08);
  --gray-alpha-100: rgba(var(--gray-rgb), 0.05);

  --button-primary-hover: #383838;
  --button-secondary-hover: #f2f2f2;

  display: grid;
  grid-template-rows: 20px 1fr 20px;
  align-items: center;
  justify-items: center;
  min-height: 100svh;
  padding: 80px;
  gap: 64px;
  font-family: var(--font-geist-sans);
}

@media (prefers-color-scheme: dark) {
  .page {
    --gray-rgb: 255, 255, 255;
    --gray-alpha-200: rgba(var(--gray-rgb), 0.145);
    --gray-alpha-100: rgba(var(--gray-rgb), 0.06);

    --button-primary-hover: #ccc;
    --button-secondary-hover: #1a1a1a;
  }
}

.main {
  display: flex;
  flex-direction: column;
  gap: 32px;
  grid-row-start: 2;
}

.main ol {
  font-family: var(--font-geist-mono);
  padding-left: 0;
  margin: 0;
  font-size: 14px;
  line-height: 24px;
  letter-spacing: -0.01em;
  list-style-position: inside;
}

.main li:not(:last-of-type) {
  margin-bottom: 8px;
}

.main code {
  font-family: inherit;
  background: var(--gray-alpha-100);
  padding: 2px 4px;
  border-radius: 4px;
  font-weight: 600;
}

.ctas {
  display: flex;
  gap: 16px;
}

.ctas a {
  appearance: none;
  border-radius: 128px;
  height: 48px;
  padding: 0 20px;
  border: none;
  border: 1px solid transparent;
  transition:
    background 0.2s,
    color 0.2s,
    border-color 0.2s;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 16px;
  line-height: 20px;
  font-weight: 500;
}

a.primary {
  background: var(--foreground);
  color: var(--background);
  gap: 8px;
}

a.secondary {
  border-color: var(--gray-alpha-200);
  min-width: 180px;
}

.footer {
  grid-row-start: 3;
  display: flex;
  gap: 24px;
}

.footer a {
  display: flex;
  align-items: center;
  gap: 8px;
}

.footer img {
  flex-shrink: 0;
}

/* Enable hover only on non-touch devices */
@media (hover: hover) and (pointer: fine) {
  a.primary:hover {
    background: var(--button-primary-hover);
    border-color: transparent;
  }

  a.secondary:hover {
    background: var(--button-secondary-hover);
    border-color: transparent;
  }

  .footer a:hover {
    text-decoration: underline;
    text-underline-offset: 4px;
  }
}

@media (max-width: 600px) {
  .page {
    padding: 32px;
    padding-bottom: 80px;
  }

  .main {
    align-items: center;
  }

  .main ol {
    text-align: center;
  }

  .ctas {
    flex-direction: column;
  }

  .ctas a {
    font-size: 14px;
    height: 40px;
    padding: 0 16px;
  }

  a.secondary {
    min-width: auto;
  }

  .footer {
    flex-wrap: wrap;
    align-items: center;
    justify-content: center;
  }
}

@media (prefers-color-scheme: dark) {
  .logo {
    filter: invert();
  }
}

================
File: app/page.tsx
================
"use client";

import React, { useState, useEffect } from "react";
import { Box, Typography, Grid, Button } from "@mui/material";
import CameraModal from "./components/CameraModal";
import { fetchPrompts } from "./services/api";
import { generatePDF } from "./services/pdfGenerator";
import { downloadImagesAsZip } from "./services/zipImages";
import "./app.css";
import { ThemeProvider } from "@mui/material/styles";
import theme from "./theme";
import { PromptSet, Prompt, Tile } from "./types/types";

const defaultPromptSet: PromptSet = {
	name: "Select...",
	prompts: [],
};

const App: React.FC = () => {
	const [tiles, setTiles] = useState<Tile[]>([]);
	const [activeTile, setActiveTile] = useState<Tile | null>(null);
	const [promptSet, setPromptSet] = useState<PromptSet>(defaultPromptSet); // Track the selected prompt set
	const [isGeneratingPDF, setIsGeneratingPDF] = useState(false);
	const [isDownloadingImages, setIsDownloadingImages] = useState(false);
	const [language, setLanguage] = useState("en");
	const [promptSets, setPromptSets] = useState<PromptSet[]>([
		defaultPromptSet,
	]);

	// Fetch prompt sets from the server
	useEffect(() => {
		const fetchPromptSets = async () => {
			try {
				const response = await fetch("/api/promptSets");
				const data = await response.json();
				setPromptSets([defaultPromptSet, ...data]);
			} catch (error) {
				console.error("Failed to fetch prompt sets:", error);
			}
		};
		fetchPromptSets();
	}, []);

	// Load prompts dynamically from the server
	useEffect(() => {
		const loadPrompts = async () => {
			try {
				if (!promptSet._id) return;
				const prompts = await fetchPrompts(promptSet._id);
				console.log(prompts);
				setTiles(
					prompts.map((prompt: Prompt, idx: number) => ({
						id: idx,
						prompt,
						completed: false,
						image: null,
						width: 1, // Default mosaic size
						height: 1,
					}))
				);
			} catch (error) {
				console.error("Failed to load prompts:", error);
			}
		};
		loadPrompts();
	}, [promptSet]);

	const markTileCompleted = (id: number, image: string | null) => {
		setTiles((prevTiles) =>
			prevTiles.map((tile) =>
				tile.id === id ? { ...tile, completed: !!image, image } : tile
			)
		);
		setActiveTile(null);
	};

	// Generate mosaic sizes dynamically based on image orientation
	const calculateMosaicSize = (orientation: "landscape" | "portrait") => {
		if (orientation === "portrait") {
			return { width: 1, height: Math.random() > 0.5 ? 2 : 1 }; // 1x1 or 1x2
		} else {
			return { width: Math.random() > 0.5 ? 2 : 1, height: 1 }; // 1x1 or 2x1
		}
	};

	// Generate and download the PDF
	const downloadPDF = async () => {
		try {
			setIsGeneratingPDF(true);
			const pdfBlob = await generatePDF(
				"SnapQuest: " + promptSet,
				tiles.map((tile) => ({
					prompt: tile.prompt.fullPrompt[language],
					image: tile.image,
					width: tile.width,
					height: tile.height,
				}))
			);
			const url = URL.createObjectURL(pdfBlob);
			const link = document.createElement("a");
			link.href = url;
			link.download = "snapquest-bingo.pdf";
			link.click();
			URL.revokeObjectURL(url);
		} catch (error) {
			console.error("Failed to generate PDF:", error);
		} finally {
			setIsGeneratingPDF(false);
		}
	};

	// Download all images as a zip file
	const downloadImages = async () => {
		try {
			setIsDownloadingImages(true);
			await downloadImagesAsZip(tiles);
		} catch (error) {
			console.error("Failed to download images:", error);
		} finally {
			setIsDownloadingImages(false);
		}
	};

	return (
		<ThemeProvider theme={theme}>
			<Box p={4}>
				<Typography variant="h3" gutterBottom className=" title">
					SnapQuest
				</Typography>

				{/* Dropdown for prompt set selection */}

				<Box
					mb={2}
					style={{
						display: "flex",
						gap: "10px",
						alignItems: "center",
					}}
				>
					<Typography
						variant="h4"
						gutterBottom
						className="prompt-set-title"
					>
						{promptSet.name === "Select..."
							? "Select a Prompt Set:"
							: promptSet.name.slice(0, 1).toUpperCase() +
							  promptSet.name.slice(1)}
					</Typography>
					<select
						value={promptSet.name}
						onChange={(e) =>
							setPromptSet(
								promptSets.find(
									(promptSet) =>
										promptSet._id === e.target.value
								) || promptSets[0]
							)
						}
						style={{
							padding: "0.25rem",
							marginTop: "0.25rem",
							marginBottom: "1rem",
						}}
					>
						{promptSets.map((promptSet) => (
							<option value={promptSet._id} key={promptSet._id}>
								{promptSet.name}
							</option>
						))}
					</select>
				</Box>

				{tiles.length > 0 && (
					<Grid
						container
						spacing={2}
						sx={{
							display: "grid",
							gridTemplateColumns:
								"repeat(auto-fit, minmax(150px, 1fr))",
							gap: "20px",
						}}
					>
						{console.log(JSON.stringify(tiles, null, 2))}
						{tiles.map((tile) => (
							<Box
								key={tile.id}
								sx={{
									display: "flex",
									flexDirection: "column",
									alignItems: "center",
								}}
							>
								{/* Button or Image */}
								<Button
									fullWidth
									variant={
										tile.completed
											? "contained"
											: "outlined"
									}
									color={
										tile.completed ? "success" : "primary"
									}
									onClick={() => setActiveTile(tile)}
									sx={{
										height: "150px", // Adjust to fit the layout
										backgroundImage: tile.image
											? `url(${tile.image})`
											: "none",
										backgroundSize: "cover",
										backgroundPosition: "center",
										display: "flex",
										alignItems: "center",
										justifyContent: "center",
										color: tile.image ? "white" : "inherit",
									}}
								>
									{!tile.image
										? tile.prompt.shortPrompt[language]
										: null}
								</Button>

								{/* Prompt below the button/image */}
								{tile.completed && (
									<Typography
										variant="body2"
										sx={{
											marginTop: "10px",
											textAlign: "center",
											wordBreak: "break-word",
											maxWidth: "100%",
											color: "#6c757d",
										}}
									>
										{tile.prompt.shortPrompt[language]}
									</Typography>
								)}
							</Box>
						))}
					</Grid>
				)}

				{/* Modal for capturing/uploading images */}
				{activeTile && (
					<CameraModal
						tile={activeTile}
						onClose={() => setActiveTile(null)}
						onSave={(id, image, orientation) =>
							markTileCompleted(id, image)
						}
						language={language}
					/>
				)}

				{/* Fixed download buttons */}
				<Box className="download-buttons">
					<Button
						variant="contained"
						color="primary"
						onClick={downloadPDF}
						disabled={isGeneratingPDF}
					>
						{isGeneratingPDF ? "Generating PDF..." : "Download PDF"}
					</Button>
					<Button
						variant="contained"
						color="secondary"
						onClick={downloadImages}
						disabled={isDownloadingImages}
					>
						{isDownloadingImages
							? "Downloading..."
							: "Download Images"}
					</Button>
				</Box>
			</Box>
		</ThemeProvider>
	);
};

export default App;

================
File: app/theme.ts
================
import { createTheme } from '@mui/material/styles';

const theme = createTheme({
  palette: {
    primary: {
      main: '#57e389', // Primary color
    },
    background: {
      default: '#121212', // Background color for the whole app
      paper: '#1e1e1e',   // Background color for surfaces (e.g., Paper, Cards)
    },
    text: {
      primary: '#ffffff', // Text color on primary background
      secondary: '#b3b3b3', // Secondary text (e.g., subtitles, hints)
    },
  },
  typography: {
    fontFamily: '"Roboto", "Helvetica", "Arial", sans-serif', // Custom font family
    fontSize: 14, // Base font size
  },
  components: {
    MuiButton: {
      styleOverrides: {
        root: {
          borderRadius: 8, // Rounded corners for all buttons
          textTransform: 'none', // Disable uppercase styling
        },
        contained: {
          backgroundColor: '#57e389',
          color: '#121212',
          '&:hover': {
            backgroundColor: '#4ed47a', // Slightly darker shade for hover
          },
        },
      },
    },
  },
});

export default theme;

================
File: .gitignore
================
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*
.next

node_modules
dist
dist-ssr
*.local

.env

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

================
File: eslint.config.js
================
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'

export default tseslint.config(
  { ignores: ['dist'] },
  {
    extends: [js.configs.recommended, ...tseslint.configs.recommended],
    files: ['**/*.{ts,tsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...reactHooks.configs.recommended.rules,
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
)

================
File: index.html
================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + React + TS</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>

================
File: mongotest.cjs
================
const { MongoClient, ServerApiVersion } = require("mongodb");
require("dotenv").config({ path: "../.env" });
const uri = process.env.MONGODB_URI;
console.log(process);
// Create a MongoClient with a MongoClientOptions object to set the Stable API version
const client = new MongoClient(uri, {
	serverApi: {
		version: ServerApiVersion.v1,
		strict: true,
		deprecationErrors: true,
	},
});
async function run() {
	try {
		// Connect the client to the server	(optional starting in v4.7)
		await client.connect();
		// Send a ping to confirm a successful connection
		await client.db("admin").command({ ping: 1 });
		console.log(
			"Pinged your deployment. You successfully connected to MongoDB!"
		);
	} finally {
		// Ensures that the client will close when you finish/error
		await client.close();
	}
}
run().catch(console.dir);

================
File: mongoUpload.cjs
================
const { MongoClient, ServerApiVersion, ObjectId } = require("mongodb");
require("dotenv").config();

const uri = process.env.MONGODB_URI;

console.log(process.env);

const client = new MongoClient(uri, {
	serverApi: {
		version: ServerApiVersion.v1,
		strict: true,
		deprecationErrors: true,
	},
});

// The data to upload
const promptSets = {
	boleishons: [
		{
			fullPrompt: {
				en: "Find a book that screams boleishon (us vibes! 🥳✨)",
				es: "Encuentra un libro que grite boleishon (¡vibras de nosotros! 🥳✨)",
			},
			shortPrompt: {
				en: "Boleishon vibes 🎉",
				es: "Vibras boleishon 🎉",
			},
		},
		{
			fullPrompt: {
				en: "A book with the most porb cover you can find (bonus points for romantic flair! 💖📖)",
				es: "Un libro con la portada más porb que puedas encontrar (¡puntos extra por el toque romántico! 💖📖)",
			},
			shortPrompt: {
				en: "Most porb cover 💌",
				es: "La portada más porb 💌",
			},
		},
		{
			fullPrompt: {
				en: "A book that would fix your bowlly life if you could read it 🛠️📚",
				es: "Un libro que arreglaría tu vida bowlly si pudieras leerlo 🛠️📚",
			},
			shortPrompt: {
				en: "Bowlly life fixer 🔧",
				es: "Arregla vidas bowlly 🔧",
			},
		},
		{
			fullPrompt: {
				en: "A book by an author whose name makes you go Boludo, who?! 🤔",
				es: "Un libro de un autor cuyo nombre te hace decir Boludo, ¿quién?! 🤔",
			},
			shortPrompt: {
				en: "Unknown author ❓",
				es: "Autor desconocido ❓",
			},
		},
		{
			fullPrompt: {
				en: "A book that feels like our cozy moments together 🛋️☕",
				es: "Un libro que se siente como nuestros momentos acogedores juntos 🛋️☕",
			},
			shortPrompt: {
				en: "Feels like home 🏡",
				es: "Se siente como en casa 🏡",
			},
		},
		{
			fullPrompt: {
				en: "A book with a title that's basically a philosophical riddle 🤯📘",
				es: "Un libro con un título que básicamente es un acertijo filosófico 🤯📘",
			},
			shortPrompt: {
				en: "Title as question 🌀",
				es: "Título como pregunta 🌀",
			},
		},
		{
			fullPrompt: {
				en: "A book about something that makes your porb heart sing 🎶💞",
				es: "Un libro sobre algo que hace cantar tu corazón porb 🎶💞",
			},
			shortPrompt: {
				en: "About something you love ❤️",
				es: "Sobre algo que amas ❤️",
			},
		},
		{
			fullPrompt: {
				en: "A book set in a dream destination for us (hello, future trip? ✈️🌍)",
				es: "Un libro ambientado en un destino soñado para nosotros (¿hola, futuro viaje? ✈️🌍)",
			},
			shortPrompt: {
				en: "Dream destination 🌅",
				es: "Destino soñado 🌅",
			},
		},
		{
			fullPrompt: {
				en: "A book with an animal friend on the cover 🐾📕",
				es: "Un libro con un amigo animal en la portada 🐾📕",
			},
			shortPrompt: {
				en: "Animal on cover 🐶",
				es: "Animal en la portada 🐶",
			},
		},
		{
			fullPrompt: {
				en: "A book with a number that feels like it could be part of a logic puzzle 🧩🔢",
				es: "Un libro con un número que parece parte de un rompecabezas lógico 🧩🔢",
			},
			shortPrompt: {
				en: "Number in title 7️⃣",
				es: "Número en el título 7️⃣",
			},
		},
		{
			fullPrompt: {
				en: "A book written in verse, because poetry is rad idk ✍️🎭",
				es: "Un libro escrito en verso, porque la poesía mola, no sé ✍️🎭",
			},
			shortPrompt: {
				en: "Written in verse 🖋️",
				es: "Escrito en verso 🖋️",
			},
		},
		{
			fullPrompt: {
				en: "A book whose title alone makes you laugh like a boludo 😂📚",
				es: "Un libro cuyo título por sí solo te hace reír como un boludo 😂📚",
			},
			shortPrompt: {
				en: "Funny title 🤣",
				es: "Título divertido 🤣",
			},
		},
		{
			fullPrompt: {
				en: "A book published the year one of us made the world better by being born 🎂📖",
				es: "Un libro publicado el año en que uno de nosotros hizo el mundo mejor al nacer 🎂📖",
			},
			shortPrompt: {
				en: "From your birth year 🌟",
				es: "De tu año de nacimiento 🌟",
			},
		},
		{
			fullPrompt: {
				en: "A book with an opening line that hits like an epic philosophical quote 😱📜",
				es: "Un libro con una línea de apertura que impacta como una cita filosófica épica 😱📜",
			},
			shortPrompt: {
				en: "Epic first sentence 💥",
				es: "Primera frase épica 💥",
			},
		},
		{
			fullPrompt: {
				en: "A book with illustrations as beautiful as a peanor 🎨🌟",
				es: "Un libro con ilustraciones tan hermosas como un peanor 🎨🌟",
			},
			shortPrompt: {
				en: "Illustrations inside 🖼️",
				es: "Ilustraciones dentro 🖼️",
			},
		},
		{
			fullPrompt: {
				en: "A book that feels as mysterious as trying cum a puzor 🕵️‍♂️📘",
				es: "Un libro que se siente tan misterioso como intentar cum a puzor 🕵️‍♂️📘",
			},
			shortPrompt: {
				en: "Feels mysterious 🔮",
				es: "Se siente misterioso 🔮",
			},
		},
		{
			fullPrompt: {
				en: "A book you’d gift to someone you porb as much as me (spoiler: impossible) 🎁❤️",
				es: "Un libro que regalarías a alguien que porbeas tanto como a mí (spoiler: imposible) 🎁❤️",
			},
			shortPrompt: {
				en: "Great gift 🎀",
				es: "Gran regalo 🎀",
			},
		},
		{
			fullPrompt: {
				en: "A book with a character who shares your name and might share your boludo vibe 😎📖",
				es: "Un libro con un personaje que comparte tu nombre y quizás tu vibra de boludo 😎📖",
			},
			shortPrompt: {
				en: "Your name in it ✍️",
				es: "Tu nombre en él ✍️",
			},
		},
		{
			fullPrompt: {
				en: "A book that you think future boludos would treasure in 100 years 📜🚀",
				es: "Un libro que crees que los futuros boludos atesorarán en 100 años 📜🚀",
			},
			shortPrompt: {
				en: "Future bestseller 📚",
				es: "Éxito de ventas futuro 📚",
			},
		},
		{
			fullPrompt: {
				en: "A book with a flower on the cover, because porb is blooming everywhere 🌸📕",
				es: "Un libro con una flor en la portada, porque porb está floreciendo por todas partes 🌸📕",
			},
			shortPrompt: {
				en: "Flower on cover 🌺",
				es: "Flor en la portada 🌺",
			},
		},
		{
			fullPrompt: {
				en: "A book set during a holiday that feels like it could be ours 🎄☀️",
				es: "Un libro ambientado en unas vacaciones que se sienten como nuestras 🎄☀️",
			},
			shortPrompt: {
				en: "Set during a holiday 🎉",
				es: "Ambientado en vacaciones 🎉",
			},
		},
		{
			fullPrompt: {
				en: "A book by an author who shares your initials (fate or coincidence? 🤷‍♀️📘)",
				es: "Un libro de un autor que comparte tus iniciales (¿destino o coincidencia? 🤷‍♀️📘)",
			},
			shortPrompt: {
				en: "Author with your initials 🧐",
				es: "Autor con tus iniciales 🧐",
			},
		},
		{
			fullPrompt: {
				en: "A book with more pages than the number of serp serp we produced 📏📚",
				es: "Un libro con más páginas que la cantidad de serp serp que produjimos 📏📚",
			},
			shortPrompt: {
				en: "500+ pages 📖",
				es: "500+ páginas 📖",
			},
		},
		{
			fullPrompt: {
				en: "A book from a genre that makes you step out of your comfort zone 🌌📖",
				es: "Un libro de un género que te saca de tu zona de confort 🌌📖",
			},
			shortPrompt: {
				en: "New genre for you 🌟",
				es: "Nuevo género para ti 🌟",
			},
		},
	],
	books: [
		{
			fullPrompt: {
				en: "A book that reminds you of us",
				es: "Un libro que te recuerde a nosotros",
			},
			shortPrompt: {
				en: "Reminds you of us",
				es: "Te recuerda a nosotros",
			},
		},
		{
			fullPrompt: {
				en: "A book with the weirdest cover",
				es: "Un libro con la portada más rara",
			},
			shortPrompt: {
				en: "Weirdest cover",
				es: "Portada más rara",
			},
		},
		{
			fullPrompt: {
				en: "A book with a blue spine",
				es: "Un libro con lomo azul",
			},
			shortPrompt: {
				en: "Blue spine",
				es: "Lomo azul",
			},
		},
		{
			fullPrompt: {
				en: "A book by an author you’ve never heard of",
				es: "Un libro de un autor que nunca hayas oído nombrar",
			},
			shortPrompt: {
				en: "Unknown author",
				es: "Autor desconocido",
			},
		},
		{
			fullPrompt: {
				en: "A book that feels like home",
				es: "Un libro que se siente como en casa",
			},
			shortPrompt: {
				en: "Feels like home",
				es: "Se siente como en casa",
			},
		},
		{
			fullPrompt: {
				en: "A book with a title that’s a question",
				es: "Un libro con un título que sea una pregunta",
			},
			shortPrompt: {
				en: "Title as question",
				es: "Título como pregunta",
			},
		},
		{
			fullPrompt: {
				en: "A book about something you love",
				es: "Un libro sobre algo que amas",
			},
			shortPrompt: {
				en: "About something you love",
				es: "Sobre algo que amas",
			},
		},
		{
			fullPrompt: {
				en: "A book set in a place you’ve always wanted to visit",
				es: "Un libro ambientado en un lugar que siempre quisiste visitar",
			},
			shortPrompt: {
				en: "Dream destination",
				es: "Destino soñado",
			},
		},
		{
			fullPrompt: {
				en: "A book with an animal on the cover",
				es: "Un libro con un animal en la portada",
			},
			shortPrompt: {
				en: "Animal on cover",
				es: "Animal en la portada",
			},
		},
		{
			fullPrompt: {
				en: "A book with a number in the title",
				es: "Un libro con un número en el título",
			},
			shortPrompt: {
				en: "Number in title",
				es: "Número en el título",
			},
		},
		{
			fullPrompt: {
				en: "A book written in verse",
				es: "Un libro escrito en verso",
			},
			shortPrompt: {
				en: "Written in verse",
				es: "Escrito en verso",
			},
		},
		{
			fullPrompt: {
				en: "A book that makes you laugh just from its title",
				es: "Un libro que te haga reír solo con su título",
			},
			shortPrompt: {
				en: "Funny title",
				es: "Título divertido",
			},
		},
		{
			fullPrompt: {
				en: "A book from the year you were born",
				es: "Un libro del año en que naciste",
			},
			shortPrompt: {
				en: "From your birth year",
				es: "De tu año de nacimiento",
			},
		},
		{
			fullPrompt: {
				en: "A book with an epic first sentence",
				es: "Un libro con una primera frase épica",
			},
			shortPrompt: {
				en: "Epic first sentence",
				es: "Primera frase épica",
			},
		},
		{
			fullPrompt: {
				en: "A book with illustrations inside",
				es: "Un libro con ilustraciones dentro",
			},
			shortPrompt: {
				en: "Illustrations inside",
				es: "Ilustraciones dentro",
			},
		},
		{
			fullPrompt: {
				en: "A book that feels mysterious",
				es: "Un libro que se siente misterioso",
			},
			shortPrompt: {
				en: "Feels mysterious",
				es: "Se siente misterioso",
			},
		},
		{
			fullPrompt: {
				en: "A book you think would make a great gift",
				es: "Un libro que crees que sería un gran regalo",
			},
			shortPrompt: {
				en: "Great gift",
				es: "Gran regalo",
			},
		},
		{
			fullPrompt: {
				en: "A book with a character who shares your name",
				es: "Un libro con un personaje que comparte tu nombre",
			},
			shortPrompt: {
				en: "Your name in it",
				es: "Tu nombre en él",
			},
		},
		{
			fullPrompt: {
				en: "A book that you think would be a bestseller in 100 years",
				es: "Un libro que crees que sería un éxito de ventas en 100 años",
			},
			shortPrompt: {
				en: "Future bestseller",
				es: "Éxito de ventas futuro",
			},
		},
		{
			fullPrompt: {
				en: "A book with a flower on the cover",
				es: "Un libro con una flor en la portada",
			},
			shortPrompt: { en: "Flower on cover", es: "Flor en la portada" },
		},
		{
			fullPrompt: {
				en: "A book set during a holiday",
				es: "Un libro ambientado durante unas vacaciones",
			},
			shortPrompt: {
				en: "Set during a holiday",
				es: "Ambientado en vacaciones",
			},
		},
		{
			fullPrompt: {
				en: "A book by an author who has the same initials as you",
				es: "Un libro de un autor que tiene las mismas iniciales que tú",
			},
			shortPrompt: {
				en: "Author with your initials",
				es: "Autor con tus iniciales",
			},
		},
		{
			fullPrompt: {
				en: "A book with more than 500 pages",
				es: "Un libro con más de 500 páginas",
			},
			shortPrompt: { en: "500+ pages", es: "500+ páginas" },
		},
		{
			fullPrompt: {
				en: "A book from a genre you don’t usually read",
				es: "Un libro de un género que normalmente no lees",
			},
			shortPrompt: {
				en: "New genre for you",
				es: "Nuevo género para ti",
			},
		},
	],
	art: [
		{
			fullPrompt: {
				en: "An artwork that feels like it could tell you a secret",
				es: "Una obra de arte que parece que podría contarte un secreto",
			},
			shortPrompt: { en: "Secretive artwork", es: "Arte secreto" },
		},
		{
			fullPrompt: {
				en: "A painting with the brightest colors you’ve ever seen",
				es: "Una pintura con los colores más brillantes que hayas visto",
			},
			shortPrompt: {
				en: "Brightest colors",
				es: "Colores más brillantes",
			},
		},
		{
			fullPrompt: {
				en: "A sculpture that looks like it could come to life",
				es: "Una escultura que parece que podría cobrar vida",
			},
			shortPrompt: { en: "Could come to life", es: "Podría cobrar vida" },
		},
		{
			fullPrompt: {
				en: "A piece that reminds you of a dream you once had",
				es: "Una pieza que te recuerda a un sueño que una vez tuviste",
			},
			shortPrompt: { en: "Dreamlike piece", es: "Pieza onírica" },
		},
		{
			fullPrompt: {
				en: "An artwork with an animal you’d want as a pet",
				es: "Una obra de arte con un animal que querrías como mascota",
			},
			shortPrompt: { en: "Pet-worthy animal", es: "Animal para mascota" },
		},
		{
			fullPrompt: {
				en: "A piece that feels like it belongs in a fairytale",
				es: "Una pieza que parece que pertenece a un cuento de hadas",
			},
			shortPrompt: {
				en: "Fairytale vibes",
				es: "Vibra de cuento de hadas",
			},
		},
		{
			fullPrompt: {
				en: "An artwork that makes you feel calm",
				es: "Una obra de arte que te hace sentir tranquilo",
			},
			shortPrompt: { en: "Calm-inducing", es: "Inductor de calma" },
		},
		{
			fullPrompt: {
				en: "A piece that you think hides a story no one has uncovered yet",
				es: "Una pieza que crees que oculta una historia que nadie ha descubierto todavía",
			},
			shortPrompt: { en: "Hidden story", es: "Historia oculta" },
		},
		{
			fullPrompt: {
				en: "An artwork with more than five people in it",
				es: "Una obra de arte con más de cinco personas en ella",
			},
			shortPrompt: { en: "Crowded artwork", es: "Arte concurrido" },
		},
		{
			fullPrompt: {
				en: "A piece that reminds you of your favorite memory",
				es: "Una pieza que te recuerda a tu recuerdo favorito",
			},
			shortPrompt: { en: "Favorite memory", es: "Recuerdo favorito" },
		},
		{
			fullPrompt: {
				en: "An artwork you’d want to hang in your bedroom",
				es: "Una obra de arte que querrías colgar en tu habitación",
			},
			shortPrompt: { en: "Bedroom piece", es: "Pieza para dormitorio" },
		},
		{
			fullPrompt: {
				en: "A piece that makes you feel small",
				es: "Una pieza que te hace sentir pequeño",
			},
			shortPrompt: {
				en: "Makes you feel small",
				es: "Te hace sentir pequeño",
			},
		},
		{
			fullPrompt: {
				en: "An artwork with a surprising texture",
				es: "Una obra de arte con una textura sorprendente",
			},
			shortPrompt: {
				en: "Surprising texture",
				es: "Textura sorprendente",
			},
		},
		{
			fullPrompt: {
				en: "A piece that seems out of place in the museum",
				es: "Una pieza que parece fuera de lugar en el museo",
			},
			shortPrompt: { en: "Out of place", es: "Fuera de lugar" },
		},
		{
			fullPrompt: {
				en: "A piece that makes you feel powerful",
				es: "Una pieza que te hace sentir poderoso",
			},
			shortPrompt: { en: "Empowering", es: "Empoderador" },
		},
		{
			fullPrompt: {
				en: "An artwork with a hidden detail you almost missed",
				es: "Una obra de arte con un detalle oculto que casi pasas por alto",
			},
			shortPrompt: { en: "Hidden detail", es: "Detalle oculto" },
		},
		{
			fullPrompt: {
				en: "A piece that feels like it belongs in another time",
				es: "Una pieza que parece pertenecer a otro tiempo",
			},
			shortPrompt: {
				en: "Belongs to another time",
				es: "Pertenece a otro tiempo",
			},
		},
		{
			fullPrompt: {
				en: "An artwork you think would confuse its own artist",
				es: "Una obra de arte que crees que confundiría a su propio artista",
			},
			shortPrompt: {
				en: "Confusing for artist",
				es: "Confuso para el artista",
			},
		},
		{
			fullPrompt: {
				en: "A piece that feels like a portal to another world",
				es: "Una pieza que parece un portal a otro mundo",
			},
			shortPrompt: {
				en: "Portal to another world",
				es: "Portal a otro mundo",
			},
		},
		{
			fullPrompt: {
				en: "An artwork that tells you everything about the artist",
				es: "Una obra de arte que te cuenta todo sobre el artista",
			},
			shortPrompt: {
				en: "Tells about artist",
				es: "Cuenta sobre el artista",
			},
		},
		{
			fullPrompt: {
				en: "A piece with a symbol you recognize",
				es: "Una pieza con un símbolo que reconoces",
			},
			shortPrompt: {
				en: "Recognizable symbol",
				es: "Símbolo reconocible",
			},
		},
		{
			fullPrompt: {
				en: "An artwork that makes you want to learn more about its subject",
				es: "Una obra de arte que te hace querer aprender más sobre su tema",
			},
			shortPrompt: {
				en: "Learn about subject",
				es: "Aprender sobre el tema",
			},
		},
		{
			fullPrompt: {
				en: "A piece that feels unfinished in the best way",
				es: "Una pieza que se siente inacabada en el mejor de los sentidos",
			},
			shortPrompt: {
				en: "Beautifully unfinished",
				es: "Hermosamente inacabada",
			},
		},
		{
			fullPrompt: {
				en: "An artwork that feels like music",
				es: "Una obra de arte que se siente como música",
			},
			shortPrompt: { en: "Musical vibes", es: "Vibras musicales" },
		},
	],
	graffiti: [
		{
			fullPrompt: {
				en: "Graffiti that uses vibrant, eye-catching colors",
				es: "Un graffiti que use colores vibrantes y llamativos",
			},
			shortPrompt: { en: "Vibrant graffiti", es: "Graffiti vibrante" },
		},
		{
			fullPrompt: {
				en: "A piece of graffiti with a powerful message",
				es: "Un graffiti con un mensaje poderoso",
			},
			shortPrompt: { en: "Powerful message", es: "Mensaje poderoso" },
		},
		{
			fullPrompt: {
				en: "Graffiti that incorporates an animal in its design",
				es: "Un graffiti que incorpore un animal en su diseño",
			},
			shortPrompt: { en: "Animal graffiti", es: "Graffiti con animal" },
		},
		{
			fullPrompt: {
				en: "Graffiti that blends seamlessly into its environment",
				es: "Un graffiti que se mezcle perfectamente con su entorno",
			},
			shortPrompt: {
				en: "Blends with environment",
				es: "Se mezcla con el entorno",
			},
		},
		{
			fullPrompt: {
				en: "Graffiti that feels like a tribute to a person or event",
				es: "Un graffiti que parezca un tributo a una persona o evento",
			},
			shortPrompt: { en: "Tribute graffiti", es: "Graffiti de tributo" },
		},
		{
			fullPrompt: {
				en: "A piece of graffiti that tells a story",
				es: "Un graffiti que cuente una historia",
			},
			shortPrompt: {
				en: "Storytelling graffiti",
				es: "Graffiti narrativo",
			},
		},
		{
			fullPrompt: {
				en: "Graffiti with text that’s hard to decipher",
				es: "Un graffiti con texto difícil de descifrar",
			},
			shortPrompt: { en: "Mysterious text", es: "Texto misterioso" },
		},
		{
			fullPrompt: {
				en: "Graffiti that features a futuristic theme",
				es: "Un graffiti con una temática futurista",
			},
			shortPrompt: {
				en: "Futuristic graffiti",
				es: "Graffiti futurista",
			},
		},
		{
			fullPrompt: {
				en: "Graffiti that could only exist in this specific location",
				es: "Un graffiti que solo podría existir en este lugar específico",
			},
			shortPrompt: {
				en: "Site-specific graffiti",
				es: "Graffiti específico del lugar",
			},
		},
		{
			fullPrompt: {
				en: "A piece of graffiti that uses humor in its design",
				es: "Un graffiti que use el humor en su diseño",
			},
			shortPrompt: {
				en: "Humorous graffiti",
				es: "Graffiti humorístico",
			},
		},
		{
			fullPrompt: {
				en: "Graffiti that incorporates natural elements like trees or rocks",
				es: "Un graffiti que incorpore elementos naturales como árboles o rocas",
			},
			shortPrompt: {
				en: "Nature-inspired graffiti",
				es: "Graffiti inspirado en la naturaleza",
			},
		},
		{
			fullPrompt: {
				en: "A piece of graffiti that feels like a part of a larger mural",
				es: "Un graffiti que se sienta parte de un mural más grande",
			},
			shortPrompt: { en: "Mural fragment", es: "Fragmento de mural" },
		},
		{
			fullPrompt: {
				en: "Graffiti that depicts a surreal, dreamlike scene",
				es: "Un graffiti que represente una escena surrealista o onírica",
			},
			shortPrompt: { en: "Surreal graffiti", es: "Graffiti surrealista" },
		},
		{
			fullPrompt: {
				en: "Graffiti that looks like it belongs in a comic book",
				es: "Un graffiti que parezca sacado de un cómic",
			},
			shortPrompt: {
				en: "Comic-style graffiti",
				es: "Graffiti estilo cómic",
			},
		},
		{
			fullPrompt: {
				en: "A piece of graffiti that highlights local culture or history",
				es: "Un graffiti que destaque la cultura o historia local",
			},
			shortPrompt: {
				en: "Local culture graffiti",
				es: "Graffiti de cultura local",
			},
		},
		{
			fullPrompt: {
				en: "Graffiti that uses unconventional shapes or designs",
				es: "Un graffiti que use formas o diseños poco convencionales",
			},
			shortPrompt: {
				en: "Unconventional graffiti",
				es: "Graffiti poco convencional",
			},
		},
		{
			fullPrompt: {
				en: "Graffiti that appears to change depending on the angle",
				es: "Un graffiti que parezca cambiar dependiendo del ángulo",
			},
			shortPrompt: { en: "Illusory graffiti", es: "Graffiti ilusorio" },
		},
		{
			fullPrompt: {
				en: "Graffiti featuring a character that feels alive",
				es: "Un graffiti con un personaje que parezca vivo",
			},
			shortPrompt: { en: "Alive character", es: "Personaje vivo" },
		},
		{
			fullPrompt: {
				en: "A piece of graffiti that incorporates text from multiple languages",
				es: "Un graffiti que incorpore texto en varios idiomas",
			},
			shortPrompt: {
				en: "Multilingual graffiti",
				es: "Graffiti multilingüe",
			},
		},
		{
			fullPrompt: {
				en: "Graffiti that feels like it’s from the future",
				es: "Un graffiti que parezca venir del futuro",
			},
			shortPrompt: { en: "Futuristic vibes", es: "Vibras futuristas" },
		},
	],
};

async function uploadData() {
	try {
		await client.connect();

		const db = client.db("promptsDB");
		const promptsCollection = db.collection("prompts");
		const promptSetsCollection = db.collection("promptSets");

		// Upload prompts and map their IDs
		for (const [category, prompts] of Object.entries(promptSets)) {
			console.log(`Processing category: ${category}`);

			// Insert prompts and get their IDs
			const promptIds = [];
			for (const prompt of prompts) {
				const result = await promptsCollection.insertOne(prompt);
				promptIds.push(result.insertedId);
			}

			// Create a promptSet for the category
			const promptSet = {
				name: `${
					category.charAt(0).toUpperCase() + category.slice(1)
				} Prompts`,
				description: `A collection of prompts related to ${category}`,
				prompts: promptIds, // Store references to prompt IDs
			};

			// Insert the promptSet
			await promptSetsCollection.insertOne(promptSet);
			console.log(`Inserted promptSet for category: ${category}`);
		}

		console.log("All data uploaded successfully!");
	} catch (err) {
		console.error("Error uploading data:", err);
	} finally {
		await client.close();
	}
}

uploadData().catch(console.dir);

================
File: next-env.d.ts
================
/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/building-your-application/configuring/typescript for more information.

================
File: next.config.ts
================
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
	reactStrictMode: true,
	// Make sure this is not changed to 'dist' or another value
	
};

export default nextConfig;

================
File: package.json
================
{
  "name": "snap-quest",
  "version": "0.1.0",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@emotion/react": "^11.13.5",
    "@emotion/styled": "^11.13.5",
    "@mui/material": "^6.1.8",
    "@vitejs/plugin-react": "^4.3.4",
    "axios": "^1.7.8",
    "dexie": "^4.0.10",
    "dotenv": "^16.4.7",
    "express": "^4.21.1",
    "file-saver": "^2.0.5",
    "formidable": "^3.5.2",
    "jszip": "^3.10.1",
    "mongodb": "^6.12.0",
    "next": "^15.0.3",
    "pdf-lib": "^1.17.1",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "typescript-eslint": "^8.16.0",
    "vite": "^6.0.1"
  },
  "devDependencies": {
    "@types/express": "^5.0.0",
    "@types/file-saver": "^2.0.7",
    "@types/formidable": "^3.4.5",
    "@types/multer": "^1.4.12",
    "@types/node": "^20",
    "@types/react": "^18",
    "@types/react-dom": "^18",
    "eslint": "^9.15.0",
    "eslint-config-react": "^1.1.7",
    "eslint-plugin-react-hooks": "^5.0.0",
    "eslint-plugin-react-refresh": "^0.4.14",
    "typescript": "^5"
  }
}

================
File: README.md
================
# React + TypeScript + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react/README.md) uses [Babel](https://babeljs.io/) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## Expanding the ESLint configuration

If you are developing a production application, we recommend updating the configuration to enable type aware lint rules:

- Configure the top-level `parserOptions` property like this:

```js
export default tseslint.config({
  languageOptions: {
    // other options...
    parserOptions: {
      project: ['./tsconfig.node.json', './tsconfig.app.json'],
      tsconfigRootDir: import.meta.dirname,
    },
  },
})
```

- Replace `tseslint.configs.recommended` to `tseslint.configs.recommendedTypeChecked` or `tseslint.configs.strictTypeChecked`
- Optionally add `...tseslint.configs.stylisticTypeChecked`
- Install [eslint-plugin-react](https://github.com/jsx-eslint/eslint-plugin-react) and update the config:

```js
// eslint.config.js
import react from 'eslint-plugin-react'

export default tseslint.config({
  // Set the react version
  settings: { react: { version: '18.3' } },
  plugins: {
    // Add the react plugin
    react,
  },
  rules: {
    // other rules...
    // Enable its recommended rules
    ...react.configs.recommended.rules,
    ...react.configs['jsx-runtime'].rules,
  },
})
```

================
File: tsconfig.app.json
================
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "Bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"]
}

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": [
      "dom",
      "dom.iterable",
      "esnext"
    ],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": [
        "./*"
      ]
    }
  },
  "include": [
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts",
    "next-env.d.ts",
    "dist/types/**/*.ts"
  ],
  "exclude": [
    "node_modules"
  ]
}

================
File: tsconfig.node.json
================
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2022",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "Bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}

================
File: vite.config.ts
================
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
})
